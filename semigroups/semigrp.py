'''
This module contains classes for representing semigroups.
'''
# pylint: disable = no-member, protected-access, invalid-name, len-as-condition

import libsemigroups
from semigroups.elements import Transformation
from semigroups.cayley_graph import CayleyGraph
from libsemigroups import ElementABC, PythonElementNC
import networkx

class Semigroup(libsemigroups.SemigroupNC):
    r'''
    A *semigroup* is a set :math:`S`, together with a binary operation :math:`*
    :S\times S\to S`, such that :math:`S` is *associative* under :math:`*`,
    that is :math:`\forall a, b, c \in S \quad a * (b * c) = (a * b) * c`.

    Let :math:`S` is a semigroup and :math:`X\subseteq S`. The *semigroup
    generated by* :math:`X` is defined as the set of all product of elements
    of :math:`X`, together with the same operation. The elements of :math:`X`
    are called the *generators*.

    This class allows semigroups generated by sets to be represented in Python.

    Args:
        args (list):   The generators of the semigroup.

    Raises:
        ValueError: If no arguments are given.

    Examples:
        >>> from semigroups import *
        >>> S = Semigroup(Transformation([1, 2, 0]),
        ... Transformation([2, 1, 0]))
        >>> # the symmetric group
        >>> S.size()
        6
        >>> Transformation([0, 1, 2]) in S
        True
        >>> Transformation([0, 1, 0]) in S
        False
        >>> # To find the generators
        >>> S[0], S[1]
        (Transformation([1, 2, 0]), Transformation([2, 1, 0]))
    '''

    def __init__(self, *args):
        if len(args) == 1 and isinstance(args[0], list):
            self.__init__(*args[0])
            return
        elif len(args) == 0:
            raise ValueError('there must be at least 1 argument')
        elif not all(map(lambda elt: isinstance(elt, type(args[0])), args)):
            raise TypeError('generators must be of the same type')
        self._is_trans_semigroup = isinstance(args[0], Transformation)
        err_msg = 'generators must have a multiplication defined on them'
        x = args[0]
        if not isinstance(x, ElementABC):
            try:
                x * x
            except:
                raise TypeError(err_msg)

        self.gens = [g if (isinstance(g, ElementABC) and str(type(g)) !=
                      "<class 'semigroups.semifp._FPSOME'>")
                else PythonElementNC(g) for g in args]
        libsemigroups.SemigroupNC.__init__(self, self.gens)
        self._done_commute_membership = False

    def __contains__(self, x):
        if self._is_trans_semigroup:
            if not x.degree() == self.gens[0].degree():
                return False

            if self._is_perm_group():
                self.enumerate(300000)
                if self.is_done():
                    return libsemigroups.SemigroupNC.__contains__(self, x)
                if self.gens[0].degree() < 50:
                    return self._perm_group_mem(x)

        if not isinstance(x, ElementABC):
            x = PythonElementNC(x)
        return libsemigroups.SemigroupNC.__contains__(self, x)

        def size(self):
            """
            A function to find the number of elements in a semigroup.

            Returns:
                int: The number of elements of the semigroup.

            Raises:
                TypeError:  If any arguments are passed.

            Examples:

                >>> from semigroups import Semigroup, Transformation
                >>> S = Semigroup([Transformation([1, 1, 4, 5, 4, 5]),
                ...                Transformation([2, 3, 2, 3, 5, 5])])
                >>> S.size()
                5
            """
            self.enumerate(300000)
            if self.is_done():
                return libsemigroups.SemigroupNC.size(self)
            if self._is_perm_group():
                if self.gens[0].degree() < 50:
                    return self._perm_group_size()
            return libsemigroups.SemigroupNC.size(self)

    #returns a list of elements(as tuples of generators) which map s to
    #each state in its orbit and it's orbit
    def _orbit(self, s):
        X = {s}
        X_transformations = {s: ()}
        test = True

        while test:
            test = False

            for g in self.gens:
                new_elements = set(["check"])

                while not X >= new_elements:
                    X = set.union(X, new_elements)
                    new_elements = set()

                    for x in X:
                        if x != "check" and not g[x] in X:
                            new_elements.add(g[x])
                            test = True
                            X_transformations[g[x]] = (X_transformations[x] +
                                                       (g,))

                X.discard("check")

        X = list(X)
        return X_transformations, X

    def right_cayley_graph(self):
        r"""
        Let :math:`S` be a semigroup, generated by a set :math:`X`. Let
        :math:`G` be a directed graph with node set :math:`S`, and for any
        :math:`x, y \in S`, there is an edge from :math:`x` to :math:`y` if
        :math:`y = xz` for some :math:`z \in X`. This graph is called a *right
        Cayley graph* of :math:`S`.

        This is a function for finding the right Cayley graph of a semigroup,
        using the generating set it was defined with.

        Raises:
            TypeError: If any arguments are given.

        Returns:
            semigroups.cayley_graph.CayleyGraph: The right Cayley graph.

        Examples:
            >>> from semigroups import Semigroup
            >>> S = Semigroup(complex(0, 1))
            >>> G = S.right_cayley_graph()
            >>> G.ordered_adjacencies()
            [[1], [2], [3], [0]]
            >>> G.edges()
            [(0, 1), (1, 2), (2, 3), (3, 0)]
            >>> G.nodes()
            [0, 1, 2, 3]
        """

        G = CayleyGraph()
        G._adj_list = libsemigroups.SemigroupNC.right_cayley_graph(self)
        for i, adjacencies in enumerate(G._adj_list):
            G._add_node(i)
        for i, adjacencies in enumerate(G._adj_list):
            for j, adj in enumerate(adjacencies):
                G._add_edge_with_label(j, (i, adj))
        return G

    def left_cayley_graph(self):
        r"""
        Let :math:`S` be a semigroup, generated by a set :math:`X`. Let
        :math:`G` be a directed graph with node set :math:`S`, and for any
        :math:`x, y \in S`, there is an edge from :math:`x` to :math:`y` if
        :math:`y = zx` for some :math:`z \in X`. This graph is called a *left
        Cayley graph* of :math:`S`.

        This is a function for finding the left Cayley graph of a semigroup,
        using the generating set it was defined with.

        Raises:
            TypeError: If any arguments are given.

        Returns:
            semigroups.cayley_graph.CayleyGraph: The left Cayley graph.

        Examples:
            >>> from semigroups import Semigroup, Transformation
            >>> S = Semigroup(Transformation([0, 0, 0]),
            ... Transformation([1, 0, 1]))
            >>> G = S.left_cayley_graph()
            >>> G.edges()
            [(0, 0), (0, 0), (1, 2), (1, 3), (2, 2), (2, 2), (3, 0), (3, 1)]
            >>> G.ordered_adjacencies()
            [[0, 0], [2, 3], [2, 2], [0, 1]]
            >>> (G.strongly_connected_components() ==
            ... [set([0]), set([2]), set([1, 3])])
            True
        """
        G = CayleyGraph()
        G._adj_list = libsemigroups.SemigroupNC.left_cayley_graph(self)
        for i, adjacencies in enumerate(G._adj_list):
            G._add_node(i)
        for i, adjacencies in enumerate(G._adj_list):
            for j, adj in enumerate(adjacencies):
                G._add_edge_with_label(j, (i, adj))
        return G

    #Tests membership in a permutation group. Uses the Schreier-Sims algorithm.
    def _perm_group_mem(self, f):
        if not len(list(f)) == len(set(f)):
            return False
        orbit_list = []
        fnew = f
        stab = self
        n = self.gens[0].degree()

        for i in range(n - 1):
            gtrans, orbit = stab._orbit(i)
            trans = [_prod(gtrans[i],
                           Transformation(list(range(n)))) for i in orbit]
            orbit_list.append(orbit)

            if not fnew[i] in orbit:
                return False

            fnew *= trans[orbit.index(fnew[i])].inverse()
            if fnew == fnew.identity():
                return True

            new_gens = set()
            for t in trans:
                for g in stab.gens:
                    new_gens.add(tuple(t * g *
                                       (trans[orbit.index((t *
                                                           g)[i])]).inverse()))

            new_gens = [Transformation(list(g)) for g in new_gens]
            stab = Semigroup(_short_perm_group_generating_set(new_gens))
            if stab.gens == [Transformation(list(range(n)))]:
                return fnew == Transformation(list(range(n)))

    #Finds the size of a perm group using the Schreier-Sims algorithm.
    def _perm_group_size(self):
        orbit_list = []
        stab = self
        n = self.gens[0].degree()

        for i in range(n - 1):
            trans, orbit = stab._orbit(i)
            trans = [_prod(trans[i],
                           Transformation(list(range(n)))) for i in orbit]
            orbit_list.append(orbit)
            new_gens = set()

            for t in trans:
                for g in stab.gens:
                    new_gens.add(tuple(t * g *
                                       (trans[orbit.index((t *
                                                           g)[i])]).inverse()))

            new_gens = [Transformation(list(g)) for g in new_gens]
            stab = Semigroup(_short_perm_group_generating_set(new_gens))

        return _prod([len(orbit) for orbit in orbit_list], 1)

    def transformation_semigroup_isomorphism(self):
        X = list(self)
        def Isomorphism(item):
            if isinstance(item, Semigroup):
                gens = []
                for g in item.gens:
                    gens.append(Transformation([X.index(x * g) for x in X]))
                return Semigroup(gens)

            if item in self:
                return Transformation([X.index(x * item) for x in X])
            raise ValueError('''input is not in the domain
                                of this isomorphism''')

        return Isomorphism

    #Assumes self is a transformation semigroup
    def _is_perm_group(self):
        if not isinstance(self.gens[0], Transformation):
            return False
        return all(len(list(a)) == len(set(a)) for a in self.gens)

def FullTransformationMonoid(n):
    r'''
    A semigroup :math:`S` is a *moniod* if it has an *identity* element. That
    is, an element :math:`e\in S` such that :math:`ea = ae = a \quad \forall a
    \in S`.

    Let :math:`n\in\mathbb{N}`. The set of all transformations of degree
    :math:`n` forms a monoid, called the *full transformation monoid*.

    This function returns the full transformation monoid of degree :math:`n`,
    for any given :math:`n\in\mathbb{N}`.

    Args:
        n (int):    The degree of the full transformation monoid.

    Returns:
        semigroups.semigrp.Semigroup: The full transformation monoid.

    Raises:
        TypeError:  If the degree is not an int.
        ValueError: If the degree is not positive.

    Examples:
        >>> from semigroups import FullTransformationMonoid
        >>> S = FullTransformationMonoid(3)
        >>> S.size()
        27
    '''
    if not isinstance(n, int):
        raise TypeError('degree of transformation must be an int')
    if n < 1:
        raise ValueError('degree of transformation must be positive')

    if n == 1:
        return Semigroup(Transformation([0]))
    elif n == 2:
        return Semigroup(Transformation([1, 0]), Transformation([0, 0]))

    return Semigroup([Transformation([1, 0] + list(range(2, n))),
                      Transformation([0, 0] + list(range(2, n))),
                      Transformation([n - 1] + list(range(n - 1)))])

def transformation_direct_product(*args):
    r'''
    Given some Transformation Monoids constructs a Transformation
    Monoid which is isomorphic to their direct product

    Args:
        args (list): The Transformation Monoids.

    Raises:
        TypeError: If arguments are not Semigroups.
        ValueError: If Semigroups are not Transformation Semigroups.

    Examples:
        >>> from semigroups import FpMonoid
        >>> S = FpMonoid("a",[["a^50", "1"]])
        >>> T = S.transformation_semigroup_isomorphism()(S)
        >>> Prod = transformation_direct_product(T, T)
        >>> Prod.size()
        2500
    '''
    if not all(isinstance(semigrp, Semigroup) for semigrp in args):
        raise TypeError('inputs must be semigroups')
    if not all(isinstance(semi.gens[0], Transformation) for semi in args):
        raise ValueError('semigroups must be Transformation Semigroups')
    length = sum(S.gens[0].degree() for S in args)
    identity = list(range(length))
    out = [Transformation(identity)]
    usedcount = 0
    for semigroup in args:
        deg = semigroup[0].degree()
        for trans in semigroup.gens:
            new_img_list = identity[:]
            new_img_list[usedcount: usedcount + deg] = [usedcount + i for i in list(trans)]
            out.append(Transformation(new_img_list))
        usedcount += deg
    return Semigroup(out)

#Given a generating set for a group, this function attempts to find a smaller
#generating set for the same group.
def _short_perm_group_generating_set(big):
    tableau = {}
    current_gens = big[:]
    new_gens = current_gens[:]
    for j in range(big[0].degree()):
        current_gens = new_gens[:]
        new_gens = []
        for g in current_gens:
            if (j, g[j]) not in tableau.keys():
                tableau[(j, g[j])] = g
                new_gens.append(g)
            elif g.inverse() * tableau[(j, g[j])] != g.identity():
                new_gens.append(g.inverse() * tableau[(j, g[j])])
    output = []
    for g in new_gens:
        if not g in output:
            output.append(g)
    return output

#Calculates the product of a list.
def _prod(L, identity=0):
    if len(L) == 0:
        return identity
    out = L[0]
    for l in L[1:]:
        out *= l
    return out

def symmetric_group(n):
    r'''
    Let :math:`n\in\mathbb{N}`. The set of all permutations of degree
    :math:`n` forms a group, under composition of functions, called the
    *symmetric group*.

    This function returns the symmetric group of degree :math:`n`, for any
    given :math:`n\in\mathbb{N}`.

    Args:
        n (int):    The degree of the symmetric group.

    Returns:
        semigroups.semigrp.Semigroup: The symmetric group.

    Raises:
        TypeError:  If the degree is not an int.
        ValueError: If the degree is not positive.

    Examples:
        >>> from semigroups import symmetric_group
        >>> S = symmetric_group(5)
        >>> S.size()
        120
    '''
    if not isinstance(n, int):
        raise TypeError('degree of permutation must be an int')
    if n < 1:
        raise ValueError('degree of permutation must be positive')

    if n == 1:
        return Semigroup(Transformation([0]))
    return Semigroup(Transformation(list(range(1, n)) + [0]),
                     Transformation([1, 0] + list(range(2, n))))

def transformation_dihedral_group(n):
    r'''
    Let :math:`n\in\mathbb{N}`. The *dihedral group* of size :math:`2n` is a
    subgroup of the symmetric group on :math:`n` points, generated by the set
    :math:`\{(0 \ 1 \ \ldots n), (0 \ n)(1 \ n-1)\cdots \}`.

    This function returns the dihedral group of order :math:`2n`, for any
    given :math:`n\in\mathbb{N}`.

    Args:
        n (int):    The degree of the dihedral group.

    Returns:
        semigroups.semigrp.Semigroup: The dihedral group.

    Raises:
        TypeError:  If the degree is not an int.
        ValueError: If the degree is not positive.

    Examples:
        >>> from semigroups import transformation_dihedral_group
        >>> S = transformation_dihedral_group(100)
        >>> S.size()
        200
    '''
    if not isinstance(n, int):
        raise TypeError('degree of permutation must be an int')
    if n < 1:
        raise ValueError('degree of permutation must be positive')
    if n == 1:
        return Semigroup(Transformation([1, 0]))
    if n == 2:
        return Semigroup(Transformation([1, 0, 2, 3]),
                         Transformation([0, 1, 3, 2]))
    return Semigroup(Transformation(list(range(1, n)) + [0]),
                     Transformation([0] + list(range(n - 1, 0, -1))))
