'''
This module contains classes for representing semigroups.
'''
# pylint: disable = no-member, protected-access, invalid-name

import libsemigroups
from semigroups.elements import Transformation
from libsemigroups import ElementABC, PythonElementNC


class Semigroup(libsemigroups.SemigroupNC):
    '''
    A class for handles to libsemigroups semigroups

    Examples:
        >>> from semigroups import Semigroup, Transformation
        >>> S = Semigroup(Transformation([1, 2, 0]), Transformation([2, 1, 0]))
        >>> # the symmetric group
        >>> S.size()
        6
    '''
    def __init__(self, *args):
        if len(args) == 1 and isinstance(args[0], list):
            self.__init__(*args[0])
            return
        elif len(args) == 0:
            ValueError('there must be at least 1 argument')

        gens = [g if (isinstance(g, ElementABC) and str(type(g)) !=
                      "<class 'semigroups.semifp._FPSOME'>")
                else PythonElementNC(g) for g in args]
<<<<<<< 68cb4b5b17a42d3de3c937bcaffcbe726630ef9b
        libsemigroups.SemigroupNC.__init__(self, gens)
=======
        libsemigroups.SemigroupNC.__init__(self, self.gens)
        self._done_commute_in = False

    def right_cayley_graph(self):
        r"""
        Let :math:`S` be a semigroup, generated by a set :math:`X`. Let
        :math:`G` be a directed graph with node set :math:`S`, and for any
        :math:`x, y \in S`, there is an edge from :math:`x` to :math:`y` if
        :math:`y = xz` for some :math:`z \in X`. This graph is called a *right
        Cayley graph* of :math:`S`.

        This is a function for finding the right Cayley graph of a semigroup,
        using the generating set it was defined with.

        Raises:
            TypeError: If any arguments are given.

        Returns:
            semigroups.cayley_graph.CayleyGraph: The right Cayley graph.

        Examples:
            >>> from semigroups import Semigroup
            >>> S = Semigroup(complex(0, 1))
            >>> G = S.right_cayley_graph()
            >>> G.ordered_adjacencies()
            [[1], [2], [3], [0]]
            >>> G.edges()
            [(0, 1), (1, 2), (2, 3), (3, 0)]
            >>> G.nodes()
            [0, 1, 2, 3]
        """

        G = CayleyGraph()
        G._adjacencies_list = libsemigroups.SemigroupNC.right_cayley_graph(self)
        for i, adjacencies in enumerate(G._adjacencies_list):
            G._add_node(i)
        for i, adjacencies in enumerate(G._adjacencies_list):
            for j, adj in enumerate(adjacencies):
                G._add_edge_with_label(j, (i, adj))
        return G

    def left_cayley_graph(self):
        r"""
        Let :math:`S` be a semigroup, generated by a set :math:`X`. Let
        :math:`G` be a directed graph with node set :math:`S`, and for any
        :math:`x, y \in S`, there is an edge from :math:`x` to :math:`y` if
        :math:`y = zx` for some :math:`z \in X`. This graph is called a *left
        Cayley graph* of :math:`S`.

        This is a function for finding the left Cayley graph of a semigroup,
        using the generating set it was defined with.

        Raises:
            TypeError: If any arguments are given.

        Returns:
            semigroups.cayley_graph.CayleyGraph: The left Cayley graph.

        Examples:
            >>> from semigroups import Semigroup, Transformation
            >>> S = Semigroup(Transformation([0, 0, 0]),
            ... Transformation([1, 0, 1]))
            >>> G = S.left_cayley_graph()
            >>> G.edges()
            [(0, 0), (0, 0), (1, 2), (1, 3), (2, 2), (2, 2), (3, 0), (3, 1)]
            >>> G.ordered_adjacencies()
            [[0, 0], [2, 3], [2, 2], [0, 1]]
            >>> G.strongly_connected_components()
            [set([0]), set([2]), set([1, 3])]
        """
        G = CayleyGraph()
        G._adjacencies_list = libsemigroups.SemigroupNC.left_cayley_graph(self)
        for i, adjacencies in enumerate(G._adjacencies_list):
            G._add_node(i)
        for i, adjacencies in enumerate(G._adjacencies_list):
            for j, adj in enumerate(adjacencies):
                G._add_edge_with_label(j, (i, adj))
        return G

    def commutative_semilattice_memb(self, f):
        if self.is_done():
            return f in self

        #Ensure f has same degree as elts of the generating set
        n = self.gens[0].degree()
        if f.degree() != n:
            return False
        for generator in self.gens:
            if not TCom(f, generator):
                return False

        B = [a for a in self.gens if a * f == f]
        g = f.identity()
        for a in B:
            g *= a
        return f == g

    def commutative_membership(self, f):
        r"""
        A semigroup :math:`S` is *commutative* if :math:`\forall a,b\in S\quad
        ab = ba`. This function implements a polynomial time complexity
        algorithm to test if a given transformation is in a commutative
        transformation semigroup.

        Args:
            semigroups.elements.Transformation: A transformation to test.

        Raises:
            awaeds

        Returns:
            bool: Whether or not the semigroup is commutative.

        Examples:
            >>> from semigroups import Semigroup
            >>> S = Semigroup(complex(0, 1))
            >>> G = S.right_cayley_graph()
            >>> G.ordered_adjacencies()
            [[1], [2], [3], [0]]
            >>> G.edges()
            [(0, 1), (1, 2), (2, 3), (3, 0)]
            >>> G.nodes()
            [0, 1, 2, 3]
        """
        if self.is_done():
            return f in self

     #Ensure f has same degree as elts of self.gens, the generating set
        n = self.gens[0].degree()

        if f.degree() != n:
            return False

        #Step 0
        for generator in self.gens:
            if not TCom(f, generator):
                return False

        if not self._done_commute_in:
            #Step 1
            self._states = list(range(n))

            #The SCCs of states.
            self._SCCs = bar(self._states, self.gens)
            self._no_SCCs = len(self._SCCs)

            #sources is the union of the source SCCs of states
            self._sources = set(self._states) - set([hit(x, a) for x in self._states for a in self.gens])

            #The SCCs that elements of sources lie in. Here, SCC is used to represent the
            # SCC that x is in.
            self._sourceSCCs = [SCC for SCC in self._SCCs if self._sources.intersection(set(SCC)) != set()]

            self._SCCs_wo_redundencies = sorted(list(set(self._SCCs)))

            self._bargens = [bar_dict(generator, self._SCCs) for generator in self.gens]
            no_SCCs = len(self._SCCs_wo_redundencies)
            self._bargen_Transformations = [Transformation(index_dict_function(a, self._SCCs_wo_redundencies, no_SCCs)) for a in self._bargens]


            self._done_commute_in = True

        barf = bar_dict(f, self._SCCs)
        barf_indexed = Transformation(index_dict_function(barf, self._SCCs, self._no_SCCs))

        #The image of sources under barf.
        Z = [barf[SCC] for SCC in self._sourceSCCs]

        #An abelian group when restricted to the elements whose SCCs lie in Z.
        IZ_set = set.intersection(*[stabiliser(SCC, self.gens, self._bargens, self._states) for SCC in Z] + [set([tuple(self._states)])])
        IZ = [Transformation(list(img_tup)) for img_tup in IZ_set]
        hatA = [hat(g, self._SCCs, Z, self._states) for g in IZ]

        #Step 2
        barf_indexed = Transformation(index_dict_function(barf, self._SCCs_wo_redundencies, len(self._SCCs_wo_redundencies)))
        mem_powers_of_f = aperiodic_commutative_membership_test(barf_indexed, self._bargen_Transformations)
        if not mem_powers_of_f[0]:
            return False
        g_a = Transformation(self._states)
        for a in self.gens:
            if tuple(index_dict_function(bar_dict(a, self._SCCs), self._SCCs, self._no_SCCs)) in mem_powers_of_f[1]:
                g_a *= Transformation(list(a)) ** mem_powers_of_f[1][tuple(index_dict_function(bar_dict(a, self._SCCs), self._SCCs, self._no_SCCs))]

        #Step 3
        g_a_img_list = list(g_a)
        f_img_list = list(f)
        hat_gc_dict = {}
        for i in self._sources:
            hat_gc_dict[g_a_img_list[i]] = f_img_list[i]
        for i in set(self._states) - set(hat_gc_dict.keys()):
            hat_gc_dict[i] = i
        hat_gc = Transformation(index_dict_function(hat_gc_dict, self._states, len(self._states)))

        #Step 4
        return hat_gc in Semigroup(hatA + [Transformation(self._states)])

def TCom(a, b):
    n = a.degree()
    if b.degree() != n:
        return False
    for x in range(n):
        if hit(hit(x, b), a) != hit(hit(x, a), b):
            return False
    return True

def semi_to_trans_semi(S):
    X = list(S)
    G=[]
    for e in S.gens:
        G.append(Transformation([X.index(x * e) for x in X]))
    return Semigroup(G)

def bar(states, A):
    G = networkx.MultiDiGraph()
    for x in states:
        G.add_node(x)
    for generator in A:
        for index, image in enumerate(generator):
            G.add_edge(index, image)
    return sorted([tuple(sorted(list(x))) for x in networkx.strongly_connected_components(G)])


    #given g in a semigroup S, with a set of SCCs, where x in states is in
    #SCC SCC, we define barg to be the transformation of SCCs, such that
    #bar(xg) = (SCC)barg

def bar_dict(f, SCCs):
    #gives transformation as dictionary, with keys as input, values as image
    d = {}
    for SCC in SCCs:
        image = hit(SCC[0], f)
        for SCC2 in SCCs:
            if image in SCC2:
                d[SCC] = SCC2
                break
    return d

def good_candidates(S):
    A = S.gens
    thresholds = {}

    for a in A:
        old_test = a.identity()
        test = a
        i = 0
        while old_test != test:
            i += 1
            old_test = test
            test *= a
        thresholds[tuple(a)] = i
    maxthreshold = max(thresholds.values())
    out = []

    states = set(range(A[0].degree()))
    edges = {}
    for i in states:
        for j in states:
            edges[(i,j)] = []
            for a in A:
                if hit(i, a) == j:
                    edges[(i,j)].append(a)

    fixed_by_a_gen=[]
    for a in A:
        for i in range(A[0].degree()):
            if hit(i, a) == i:
                fixed_by_a_gen.append(i)



    for f in FullTransformationMonoid(A[0].degree()):
        check = True
        #if check and f in S:
        #    check = False
        if check:
            for a in A:
                if not TCom(f, a):
                    check = False
                    break
        if check:
            i = 1
            temp = f
            while temp != temp * f:
                if i > maxthreshold:
                    check = False
                    break
                i += 1
                temp *= f

        if check:
            image = list(f)
            for i in set(image):
                reached = set([i])
                check2 = False
                while not check2:
                    check2 = True
                    for j in states - reached:
                        temp = set(reached)
                        for k in temp:
                            if edges[(j,k)] != []:
                                reached.add(j)
                                check2 = False
                if not reached >= indecies(image,i):
                    check = False
                    break
        if check:
            check = False
            for i in range(f.degree()):
                if hit(i, f) == i:
                    if i in fixed_by_a_gen:
                        check = True
                        break

        if check:
            out.append(f)
    return out

def is_commutative_and_aperiodic(S):
    A = S.gens
    for a1 in A:
        if not all(TCom(a1, a2) for a2 in A):
            return False
    for a in A:
        pows = [a]
        while not pows[-1] * a in pows:
            pows.append(pows[-1] * a)
        if not pows[-1] * a == pows[-1]:
            return False
    return True

def distance_to_states(A):
    states = set(range(A[0].degree()))
    edges = {}
    for i in states:
        for j in states:
            edges[(i,j)] = []
            for a in A:
                if hit(i, a) == j:
                    edges[(i,j)].append(a)

    backwardslevels = []
    for i in states:
        levels = [{i}]
        new_level = {False}
        while new_level != set():
            new_level = set()
            for i in levels[-1]:
                for j in states:
                    if (edges[(j,i)] != []) and (i != j):
                        new_level.add(j)
            levels.append(new_level)
        levels = levels[:-1]
        levels = [list(s) for s in levels]
        backwardslevels.append(levels)

    return backwardslevels

def indecies(L,x):
    out = set()
    for i,j in enumerate(L):
        if j == x:
            out.add(i)
    return out

#def abelian_transformation_group_membership(f, A):
#    for a in A:
#        if not TCom(f, a):
#            return False
#    states = list(range(A[0].degree()))
#    G = networkx.MultiGraph()
#    for x in states:
#        G.add_node(x)
#    for generator in A:
#        for index, image in enumerate(generator):
#            G.add_edge(index, image)
#    orbits = sorted([tuple(sorted(list(x))) for x in networkx.connected_components(G)])
#
#    orbit_restrictions = {tuple(f): restrict_trans(f, orbits)}
#    for a in A:
#        orbit_restrictions[tuple(a)] = restrict_trans(a, orbits)
#
#    restricted_gens = []
#    for i, j in enumerate(orbits):
#        restricted_gens.append(gens_trans_abelian_elt(orbit_restrictions[tuple(f)][i],
#                                                      [orbit_restrictions[tuple(a)][i] for a in A]))
#    b = [[restricted_gens[i].count(orbit_restrictions[tuple(a)][i]) for a in A] for i,j in enumerate(restricted_gens)]
#    t = {}
#    for i in range(len(A)):
#        for a in A:
#            t{(i,i)} = min(k s.t. g[i]**k in <gk+1 ... gr>)
#            k = 1
#            while orbit_restrictions[tuple(a)][i]
#    return b

#def gens_trans_abelian_elt(f, gens):
#    tree = [cyclic_group_list(g) for g in gens]
#    deg = gens[0].degree()
#    n = x = len(tree)
#    while x > 0:
#        x -= 1
#        current_group1 = tree[x]
#        current_group2 = []
#        if 2 * x + 1 < n:
#            for i in tree[2 * x + 1]:
#                for j in current_group1:
#                    current_group2.append([i[0] * j[0], i[1] + j[1]])
#            current_group1 = condense_list_by_1st_coordinate(current_group2)
#            current_group2 = []
#        if 2 * x < n:
#            for i in tree[2 * x]:
#                for j in current_group1:
#                    current_group2.append([i[0] * j[0], i[1] + j[1]])
#            current_group1 = condense_list_by_1st_coordinate(current_group2)
#            current_group2 = []
#        tree[x] = current_group1
#    for x in tree[0]:
#        if f == x[0]:
#            return x[1]
#    return False

def condense_list_by_1st_coordinate(L):
    found = []
    out = []
    for x in L:
        if not x[0] in found:
            out.append(x)
            found.append(x[0])
    return out

def cyclic_group_list(g):
    group = [[g.identity(), []]]
    current = g
    i = 1
    while current != g.identity():
        group.append([current,[g]*i])
        i += 1
        current *= g
    return group

def aperiodic_UF_commutative_membership_testL(f, A):
    thresholds = {}
    for a in A:
        old_test = a.identity()
        test = a
        i = 0
        while old_test != test:
            i += 1
            old_test = test
            test *= a
        thresholds[tuple(a)] = i
    maxthreshold = max(thresholds.values())

    powers = {}
    for a in A:
        j = 0
        a_power_by_f = a * f
        a_power_by_f_old = f
        while a_power_by_f_old != a_power_by_f:
            j += 1
            a_power_by_f_old = a_power_by_f
            a_power_by_f *= a
        powers[tuple(a)] = thresholds[tuple(a)] - j

    test_f = f.identity()
    for a in A:
        test_f *= a ** powers[tuple(a)]
    return test_f == f, powers

def aperiodic_UF_commutative_membership_testL2(f, A):
    thresholds = {}
    for a in A:
        old_test = a.identity()
        test = a
        i = 0
        while old_test != test:
            i += 1
            old_test = test
            test *= a
        thresholds[tuple(a)] = i
    maxthreshold = max(thresholds.values())

    powers = {}
    f2 = f
    for a in A:
        j = 0
        a_power_by_f = a * f2
        a_power_by_f_old = f2
        while a_power_by_f_old != a_power_by_f:
            j += 1
            a_power_by_f_old = a_power_by_f
            a_power_by_f *= a
        powers[tuple(a)] = thresholds[tuple(a)] - j
        f2 = a_power_by_f
    test_f = f.identity()
    for a in A:
        test_f *= a ** powers[tuple(a)]
    return test_f == f, powers

def aperiodic_UF_commutative_membership_testJ(f, A):
    thresholds = {}
    for a in A:
        old_test = a.identity()
        test = a
        i = 0
        while old_test != test:
            i += 1
            old_test = test
            test *= a
        thresholds[tuple(a)] = i
    maxthreshold = max(thresholds.values())

    powers = {}
    needed_states = set(range(A[0].degree()))
    for a in A:
        j = 0
        a_power_by_f = a * f
        a_power_by_f_old = f
        while not equal_on_set(a_power_by_f_old, a_power_by_f,needed_states):
            j += 1
            a_power_by_f_old = a_power_by_f
            a_power_by_f *= a
        powers[tuple(a)] = thresholds[tuple(a)] - j
        needed_states = needed_states.intersection(set(a ** thresholds[tuple(a)]))
    test_f = f.identity()
    for a in A:
        test_f *= a ** powers[tuple(a)]
    return test_f == f, powers

def aperiodic_UF_commutative_membership_testJ2(f, A):
    thresholds = {}
    for a in A:
        old_test = a.identity()
        test = a
        i = 0
        while old_test != test:
            i += 1
            old_test = test
            test *= a
        thresholds[tuple(a)] = i
    maxthreshold = max(thresholds.values())

    powers = {}
    f2 = f
    needed_states = set(range(A[0].degree()))
    for a in A:
        j = 0
        a_power_by_f = a * f2
        a_power_by_f_old = f2
        while not equal_on_set(a_power_by_f_old, a_power_by_f,needed_states):
            j += 1
            a_power_by_f_old = a_power_by_f
            a_power_by_f *= a
        powers[tuple(a)] = thresholds[tuple(a)] - j
        f2 = a_power_by_f
        needed_states = needed_states.intersection(set(a ** thresholds[tuple(a)]))
    test_f = f.identity()
    for a in A:
        test_f *= a ** powers[tuple(a)]
    return test_f == f, powers

def aperiodic_UF_commutative_membership_testJ3(f, A):
    states = set(range(A[0].degree()))
    powers = {}
    f2 = f
    needed_states = set(range(A[0].degree()))
    for a in A:
        j = 0
        a_power_by_f = a * f2
        a_power_by_f_old = f2
        while not equal_on_set(a_power_by_f_old, a_power_by_f, needed_states):
            j += 1
            a_power_by_f_old = a_power_by_f
            a_power_by_f *= a
        powers[tuple(a)] = (threshold_of_aperiodic_restricted(a, needed_states), j)
        f2 = a_power_by_f
        needed_states = needed_states.intersection(set(a ** threshold_of_aperiodic_restricted(a, needed_states)))
    test_f = f.identity()
    for a in A:
        test_f *= a ** (powers[tuple(a)][0] - powers[tuple(a)][1])
    return test_f == f, powers

def aperiodic_UF_commutative_membership_testJ4(f, A):
    states = set(range(A[0].degree()))
    powers = {}
    f2 = f
    needed_states = set(range(A[0].degree()))
    for a in A:
        j = 0
        a_power_by_f = f2 * a
        a_power_by_f_old = f2
        while not equal_on_set(a_power_by_f_old, a_power_by_f, needed_states):
            j += 1
            a_power_by_f_old = a_power_by_f
            a_power_by_f = a_power_by_f * a
        powers[tuple(a)] = (threshold_of_aperiodic_restricted(a, needed_states), j)
        f2 = f * pseudo_trans_inverse_restricted(a_power_by_f, needed_states)
        needed_states = needed_states.intersection(set(a ** j))
    test_f = f.identity()
    for a in A:
        test_f *= a ** (powers[tuple(a)][0] - powers[tuple(a)][1])
    return test_f == f, powers

def aperiodic_UF_commutative_membership_testJ5(Trans, A):
    if len(A) != 0:
        assert(Trans.degree() == A[0].degree())
    return mem(Transformation(list(Trans) + [Trans.degree()]), [Transformation(list(a) + [a.degree()]) for a in A])

def mem(f, A):
    defined_states = [s for s in range(f.degree()) if hit(s, f) != f.degree() - 1]
    if len(A)== 0:
        return [f,[]]
    if all(hit(s, f) in [s, f.degree() - 1] for s in range(f.degree())):
        return [True, [0] * len(A)]
    gen = A[0]

    threshold = 0
    temp = gen.identity()

    while not all(hit(s, temp) == hit(s, temp * gen) for s in defined_states):
        threshold += 1
        temp *= gen

    j = 0
    temp = f
    while temp != temp * gen:
        j += 1
        temp *= gen
    assert(threshold >= j)

    gen_part_of_f = gen ** (threshold - j)

    inv = left_psudo_inverse(gen_part_of_f)

    assert(all(hit(a,inv * gen_part_of_f) == a for a in gen_part_of_f))
    fp_res = Transformation([hit(a,inv * f) if a in gen_part_of_f else f.degree() - 1 for a in range(f.degree())])

    out = mem(fp_res, A[1:])

    powers = [threshold - j] + out[1]

    testprod = prod([x[0] ** x[1] for x in zip(A,powers)])
    test = all(hit(s, testprod) == hit(s, f) for s in defined_states)
    return [test, powers]

def left_psudo_inverse(T):
    image =[]
    for i in range(T.degree()):
         if i in list(T):
             image.append(list(T).index(i))
         else:
             image.append(i)
    return Transformation(image)

def pseudo_trans_inverse_restricted(T, S):
    inverse = {}
    for i in list(T):
        for s in S:
            if hit(s, T) == i:
                inverse[s] = i
                break
    for i in set(range(T.degree())) - set(inverse.keys()):
        inverse[i] = i
    return Transformation([inverse[i] for i in range(len(inverse))])

def equal_on_set(a,b,states):
    for i in states:
        if not hit(i, a) == hit(i, b):
            return False
    return True

def threshold_of_aperiodic_restricted(T, S):
    i = 0
    temp = T.identity()
    while not equal_on_set(temp,temp * T,S):
        temp *= T
        i+=1
    return i

def prod(L, identity = 0):
    if len(L) == 0:
        return identity
    out = L[0]
    for l in L[1:]:
        out *= l
    return out

def index_dict_function(g_dict, domain, n):
    return [domain.index(g_dict[domain[i]]) for i in range(n)]

def hit(x, f):
    for i, image in enumerate(f):
        if i == x:
            return image

def stabiliser(SCC, A, bargens, states):
    return set([tuple(a) for a, barg in zip(A, bargens) if barg[SCC] == SCC]).union(set([tuple(states)]))

def hat(f, SCCs, Z, states):
    #Gives transformation as image list
    d = {}
    for SCC in SCCs:
        if SCC in Z:
            for x in SCC:
                d[x] = hit(x, f)
        else:
            for x in SCC:
                d[x] = x
    return Transformation([d[i] for i in states])
>>>>>>> stuff

def FullTransformationMonoid(n):
    '''
    Returns the full transformation monoid of degree n.
    '''
    assert isinstance(n, int) and n >= 1
    if n == 1:
        return Semigroup(Transformation([0]))
    elif n == 2:
        return Semigroup(Transformation([1, 0]), Transformation([0, 0]))

    return Semigroup([Transformation([1, 0] + list(range(2, n))),
                      Transformation([0, 0] + list(range(2, n))),
                      Transformation([n - 1] + list(range(n - 1)))])
